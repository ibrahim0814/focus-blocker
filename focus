#!/bin/bash

# Focus Blocker - Block distracting websites with intelligent session management and Spotify integration
# Usage: 
#   focus                              - Block websites and save/restore browser sessions
#   focus -s [playlist]                - Block websites + launch Spotify playlist
#   focus list                         - Show blocked sites and current status  
#   focus playlists                    - List available Spotify playlists
#   focus playlist add <name> <url>    - Add new Spotify playlist
#   focus playlist remove <name>       - Remove Spotify playlist
#   focus add <site>                   - Add site to block list
#   focus remove <site>                - Remove site from block list
#   unfocus                           - Unblock all websites

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/blocked_sites.txt"
SPOTIFY_CONFIG_FILE="$SCRIPT_DIR/spotify_config.txt"
HOSTS_FILE="/etc/hosts"
BACKUP_FILE="$SCRIPT_DIR/hosts_backup"
FOCUS_MARKER="# FOCUS_BLOCKER_START"
FOCUS_MARKER_END="# FOCUS_BLOCKER_END"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Global flag for dock-only mode
DOCK_ONLY_MODE=false

# Initialize config file if it doesn't exist
init_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" << EOF
# Focus Blocker - Blocked Sites Configuration
# Add one domain per line (without http:// or https://)
# Examples:
x.com
twitter.com
facebook.com
instagram.com
reddit.com
youtube.com
EOF
        echo -e "${GREEN}Created default config file: $CONFIG_FILE${NC}"
        echo -e "${BLUE}Edit this file to customize your blocked sites.${NC}"
    fi
}

# Initialize Spotify config file if it doesn't exist
init_spotify_config() {
    if [ ! -f "$SPOTIFY_CONFIG_FILE" ]; then
        cat > "$SPOTIFY_CONFIG_FILE" << EOF
# Focus Blocker - Spotify Configuration
# Format: PLAYLIST_NAME=spotify:playlist:PLAYLIST_ID
# Add playlists using: focus playlist add <name> <url>
# Just copy the playlist URL from Spotify - no need to convert to URI!

# Default playlist (used when no name specified with focus -s)
default=spotify:playlist:37i9dQZF1DX0XUsuxWHRQd
EOF
        echo -e "${GREEN}Created Spotify config file: $SPOTIFY_CONFIG_FILE${NC}"
        echo -e "${BLUE}Add playlists using: ${YELLOW}focus playlist add <name> <url>${NC}"
        echo -e "${BLUE}Example: ${YELLOW}focus playlist add lofi https://open.spotify.com/playlist/37i9dQZF1DWWQRwui0ExPn${NC}"
    fi
}

# Get Spotify playlist URI from config by name
get_spotify_playlist() {
    local playlist_name="$1"
    
    # Default to "default" if no name specified
    if [ -z "$playlist_name" ]; then
        playlist_name="default"
    fi
    
    if [ -f "$SPOTIFY_CONFIG_FILE" ]; then
        # Look for the named playlist
        local playlist_uri=$(grep "^$playlist_name=" "$SPOTIFY_CONFIG_FILE" | cut -d'=' -f2)
        
        if [ -n "$playlist_uri" ]; then
            echo "$playlist_uri"
        else
            echo "spotify:playlist:37i9dQZF1DX0XUsuxWHRQd"  # Fallback default
        fi
    else
        echo "spotify:playlist:37i9dQZF1DX0XUsuxWHRQd"  # Default focus playlist
    fi
}

# Convert Spotify URL to URI
convert_spotify_url_to_uri() {
    local input="$1"
    
    # If it's already a URI, return as-is
    if echo "$input" | grep -q "^spotify:playlist:"; then
        echo "$input"
        return 0
    fi
    
    # If it's a URL, extract the playlist ID
    if echo "$input" | grep -q "open.spotify.com/playlist/"; then
        local playlist_id=$(echo "$input" | sed 's/.*\/playlist\///' | sed 's/\?.*//')
        echo "spotify:playlist:$playlist_id"
        return 0
    fi
    
    # If it doesn't match either format, return empty
    echo ""
    return 1
}

# List available playlists
list_playlists() {
    echo -e "${BLUE}Available Spotify playlists:${NC}"
    if [ -f "$SPOTIFY_CONFIG_FILE" ]; then
        local count=0
        grep "^[a-zA-Z].*=" "$SPOTIFY_CONFIG_FILE" | while IFS='=' read -r name uri; do
            echo -e "  ${YELLOW}$name${NC} - $uri"
            count=$((count + 1))
        done
        
        # Count playlists
        local playlist_count=$(grep "^[a-zA-Z].*=" "$SPOTIFY_CONFIG_FILE" | wc -l | tr -d ' ')
        if [ "$playlist_count" -eq 0 ]; then
            echo -e "${YELLOW}  No playlists configured yet${NC}"
            echo -e "${BLUE}  Add one with: ${YELLOW}focus playlist add <name> <uri>${NC}"
        fi
    else
        echo -e "${RED}No Spotify config found. Run 'focus -s' to create one.${NC}"
    fi
}

# Add a playlist
add_playlist() {
    local name="$1"
    local input_url="$2"
    
    if [ -z "$name" ] || [ -z "$input_url" ]; then
        echo -e "${RED}Please specify both name and URL/URI${NC}"
        echo "Usage: focus playlist add <name> <url>"
        echo "Examples:"
        echo "  focus playlist add lofi https://open.spotify.com/playlist/37i9dQZF1DWWQRwui0ExPn"
        echo "  focus playlist add chill spotify:playlist:37i9dQZF1DX0XUsuxWHRQd"
        return 1
    fi
    
    # Convert URL to URI
    local uri=$(convert_spotify_url_to_uri "$input_url")
    
    if [ -z "$uri" ]; then
        echo -e "${RED}Invalid Spotify URL/URI format${NC}"
        echo "Supported formats:"
        echo "  • Spotify URL: https://open.spotify.com/playlist/PLAYLIST_ID"
        echo "  • Spotify URI: spotify:playlist:PLAYLIST_ID"
        echo ""
        echo "To get a playlist URL: Share playlist in Spotify > Copy link to playlist"
        return 1
    fi
    
    init_spotify_config
    
    # Check if playlist name already exists
    if grep -q "^$name=" "$SPOTIFY_CONFIG_FILE" 2>/dev/null; then
        echo -e "${YELLOW}Playlist '$name' already exists. Updating...${NC}"
        # Remove existing entry
        grep -v "^$name=" "$SPOTIFY_CONFIG_FILE" > "$SPOTIFY_CONFIG_FILE.tmp" && mv "$SPOTIFY_CONFIG_FILE.tmp" "$SPOTIFY_CONFIG_FILE"
    fi
    
    # Add new playlist
    echo "$name=$uri" >> "$SPOTIFY_CONFIG_FILE"
    echo -e "${GREEN}✓ Added playlist '$name' ($uri)${NC}"
}

# Remove a playlist
remove_playlist() {
    local name="$1"
    
    if [ -z "$name" ]; then
        echo -e "${RED}Please specify playlist name to remove${NC}"
        echo "Usage: focus playlist remove <name>"
        return 1
    fi
    
    if [ ! -f "$SPOTIFY_CONFIG_FILE" ]; then
        echo -e "${RED}No Spotify config found${NC}"
        return 1
    fi
    
    if [ "$name" = "default" ]; then
        echo -e "${RED}Cannot remove the default playlist${NC}"
        return 1
    fi
    
    if grep -q "^$name=" "$SPOTIFY_CONFIG_FILE"; then
        grep -v "^$name=" "$SPOTIFY_CONFIG_FILE" > "$SPOTIFY_CONFIG_FILE.tmp" && mv "$SPOTIFY_CONFIG_FILE.tmp" "$SPOTIFY_CONFIG_FILE"
        echo -e "${GREEN}✓ Removed playlist '$name'${NC}"
    else
        echo -e "${YELLOW}Playlist '$name' was not found${NC}"
        echo -e "${BLUE}Available playlists:${NC}"
        list_playlists
    fi
}

# Launch Spotify with focus playlist - simplified output, shows playlist name instead of song
launch_spotify_focus() {
    local playlist_name="$1"

    echo -e "${BLUE}Starting Spotify...${NC}"

    init_spotify_config
    local playlist_uri=$(get_spotify_playlist "$playlist_name")

    if [ -z "$playlist_uri" ]; then
        playlist_uri="spotify:playlist:37i9dQZF1DX0XUsuxWHRQd"  # Fallback default
        echo -e "${YELLOW}Using default playlist${NC}"
    fi

    # Open Spotify with the playlist
    open "$playlist_uri" 2>/dev/null

    # Wait for Spotify to load the playlist
    sleep 4

    # Try to automatically start playback
    local playback_started=false

    # Method 1: Try to play the playlist directly via AppleScript
    if osascript << EOF >/dev/null 2>&1
tell application "Spotify"
    -- First ensure Spotify is active
    activate
    delay 2

    -- Try to play the playlist directly
    try
        play track "$playlist_uri"
        delay 1
    on error errMsg
        -- If direct play fails, try alternative method
        try
            -- Set the playlist as current and play
            set current track to "$playlist_uri"
            delay 1
            play
        on error errMsg2
            error "Failed to start playback"
        end try
    end try
end tell
EOF
    then
        playback_started=true
    else
        # Method 2: If AppleScript fails, try a different approach

        if osascript << EOF >/dev/null 2>&1
tell application "Spotify"
    activate
    delay 2

    -- Alternative: Try to simulate clicking play button
    try
        -- Get the current view (should be the playlist)
        tell application "System Events"
            tell process "Spotify"
                delay 1
                -- Try to find and click the play button
                try
                    -- Look for play button in the main window
                    click button 1 of window 1
                on error
                    -- Fallback: just ensure Spotify is playing something
                    tell application "Spotify" to play
                end try
            end tell
        end tell
    on error errMsg
        error "Failed alternative method"
    end try
end tell
EOF
        then
            playback_started=true
        fi
    fi

    # Wait a moment for playback to start
    sleep 2

    # Final status report
    local player_state=$(osascript -e 'tell application "Spotify" to get player state' 2>/dev/null)

    if [ "$player_state" = "playing" ]; then
        # Show playlist name - determine what was actually used
        local display_name="$playlist_name"
        local actual_playlist_uri=$(get_spotify_playlist "$playlist_name")
        local default_uri="spotify:playlist:37i9dQZF1DX0XUsuxWHRQd"
        
        # If the requested playlist doesn't exist or falls back to default
        if [ "$actual_playlist_uri" = "$default_uri" ]; then
            if [ -z "$playlist_name" ] || [ "$playlist_name" = "default" ]; then
                display_name="default focus playlist"
            else
                display_name="default focus playlist"  # Non-existent playlist falls back to default
            fi
        elif [ -z "$display_name" ] || [ "$display_name" = "default" ]; then
            display_name="default focus playlist"
        fi
        
        echo -e "${GREEN}✓ Playing: $display_name${NC}"
    else
        # Fallback: Provide user instructions
        echo -e "${YELLOW}⚠️  Automatic playback didn't work${NC}"
        echo -e "${BLUE}  Please manually click the green ▶️ play button in the Spotify playlist${NC}"
    fi
}

# Create backup of original hosts file
backup_hosts() {
    if [ ! -f "$BACKUP_FILE" ]; then
        sudo cp "$HOSTS_FILE" "$BACKUP_FILE"
        echo -e "${GREEN}Backed up original hosts file${NC}"
    fi
}

# Check if focus mode is currently active
is_focused() {
    grep -q "$FOCUS_MARKER" "$HOSTS_FILE" 2>/dev/null
}

# Get blocked sites from config
get_blocked_sites() {
    if [ -f "$CONFIG_FILE" ]; then
        grep -v "^#" "$CONFIG_FILE" | grep -v "^$" | sort -u
    fi
}

# Session management directory
SESSION_DIR="$SCRIPT_DIR/.browser_sessions"

# Create session directory if it doesn't exist
init_session_dir() {
    mkdir -p "$SESSION_DIR"
}

# Check if a URL matches any blocked site
is_url_blocked() {
    local url="$1"
    if [ -z "$url" ]; then
        return 1
    fi
    
    # Extract domain from URL (remove protocol, path, etc.)
    local domain=$(echo "$url" | sed 's|https://||' | sed 's|http://||' | sed 's|www\.||' | cut -d'/' -f1 | cut -d'?' -f1 | cut -d'#' -f1)
    
    # Check if domain matches any blocked site
    while read -r blocked_site; do
        if [ -n "$blocked_site" ]; then
            # Check exact match or if domain ends with blocked site (for subdomains)
            if [ "$domain" = "$blocked_site" ] || echo "$domain" | grep -q "\.$blocked_site$"; then
                return 0  # URL is blocked
            fi
        fi
    done <<< "$(get_blocked_sites)"
    
    return 1  # URL is not blocked
}

# Save Chrome tabs using AppleScript
save_chrome_session() {
    if pgrep -f "Google Chrome" > /dev/null; then
        osascript << 'EOF' > "$SESSION_DIR/chrome_urls.txt" 2>/dev/null
tell application "Google Chrome"
    set urlList to {}
    repeat with w in windows
        repeat with t in tabs of w
            set tabURL to (URL of t as string)
            -- Skip empty tabs, new tab pages, and chrome internal pages
            if tabURL is not "" and tabURL does not start with "chrome://" and tabURL does not start with "chrome-extension://" and tabURL is not "about:blank" then
                set end of urlList to tabURL
            end if
        end repeat
    end repeat
    set AppleScript's text item delimiters to linefeed
    set urlText to urlList as string
    set AppleScript's text item delimiters to ""
    return urlText
end tell
EOF
        # Check if we have any meaningful tabs
        if [ -s "$SESSION_DIR/chrome_urls.txt" ] && [ "$(wc -l < "$SESSION_DIR/chrome_urls.txt" | tr -d ' ')" -gt 0 ]; then
            return 0
        else
            rm -f "$SESSION_DIR/chrome_urls.txt"
            return 1
        fi
    fi
    return 1
}

# Save Safari tabs using AppleScript  
save_safari_session() {
    if pgrep -f "Safari" > /dev/null; then
        osascript << 'EOF' > "$SESSION_DIR/safari_urls.txt" 2>/dev/null
tell application "Safari"
    set urlList to {}
    repeat with w in windows
        repeat with t in tabs of w
            set tabURL to (URL of t as string)
            -- Skip empty tabs, new tab pages, and blank pages
            if tabURL is not "" and tabURL does not start with "safari-extension://" and tabURL is not "about:blank" and tabURL does not contain "favorites://" then
                set end of urlList to tabURL
            end if
        end repeat
    end repeat
    set AppleScript's text item delimiters to linefeed
    set urlText to urlList as string
    set AppleScript's text item delimiters to ""
    return urlText
end tell
EOF
        # Check if we have any meaningful tabs
        if [ -s "$SESSION_DIR/safari_urls.txt" ] && [ "$(wc -l < "$SESSION_DIR/safari_urls.txt" | tr -d ' ')" -gt 0 ]; then
            return 0
        else
            rm -f "$SESSION_DIR/safari_urls.txt"
            return 1
        fi
    fi
    return 1
}

# Save Brave tabs using AppleScript (same as Chrome but for Brave)
save_brave_session() {
    if pgrep -f "Brave Browser" > /dev/null; then
        osascript << 'EOF' > "$SESSION_DIR/brave_urls.txt" 2>/dev/null
tell application "Brave Browser"
    set urlList to {}
    repeat with w in windows
        repeat with t in tabs of w
            set tabURL to (URL of t as string)
            -- Skip empty tabs, new tab pages, and brave internal pages
            if tabURL is not "" and tabURL does not start with "brave://" and tabURL does not start with "chrome://" and tabURL does not start with "chrome-extension://" and tabURL is not "about:blank" then
                set end of urlList to tabURL
            end if
        end repeat
    end repeat
    set AppleScript's text item delimiters to linefeed
    set urlText to urlList as string
    set AppleScript's text item delimiters to ""
    return urlText
end tell
EOF
        # Check if we have any meaningful tabs
        if [ -s "$SESSION_DIR/brave_urls.txt" ] && [ "$(wc -l < "$SESSION_DIR/brave_urls.txt" | tr -d ' ')" -gt 0 ]; then
            return 0
        else
            rm -f "$SESSION_DIR/brave_urls.txt"
            return 1
        fi
    fi
    return 1
}

# Restore Chrome session
restore_chrome_session() {
    if [ -f "$SESSION_DIR/chrome_urls.txt" ] && [ -s "$SESSION_DIR/chrome_urls.txt" ]; then
        
        # Parse URLs and filter out blocked sites
        # Reverse order because 'open' adds new tabs at the end, so we need to open them backwards
        # to maintain the original left-to-right tab order
        urls=$(cat "$SESSION_DIR/chrome_urls.txt" | tail -r)
        
        if [ -n "$urls" ]; then
            restored_count=0
            blocked_count=0
            
            while IFS= read -r url; do
                if [ -n "$url" ] && [ "$url" != "" ]; then
                    if is_url_blocked "$url"; then
                        blocked_count=$((blocked_count + 1))
                        echo -e "${RED}    ⚠️  Skipped blocked site: $(echo "$url" | sed 's|https://||' | sed 's|http://||' | cut -d'/' -f1)${NC}"
                    else
                        # Open URL in new tab, not new window
                        open -a "Google Chrome" "$url" 2>/dev/null
                        restored_count=$((restored_count + 1))
                        sleep 0.1  # Small delay between tab opens
                    fi
                fi
            done <<< "$urls"
            
            # Show concise summary
            if [ $blocked_count -gt 0 ]; then
                echo -e "${YELLOW}  Chrome: $restored_count tabs restored, $blocked_count blocked${NC}"
            else
                echo -e "${YELLOW}  Chrome: $restored_count tabs restored${NC}"
            fi
            
            # Only return success if we actually restored tabs
            if [ $restored_count -gt 0 ]; then
                rm -f "$SESSION_DIR/chrome_urls.txt"
                return 0
            fi
        fi
        
        rm -f "$SESSION_DIR/chrome_urls.txt"
    fi
    return 1
}

# Restore Safari session
restore_safari_session() {
    if [ -f "$SESSION_DIR/safari_urls.txt" ] && [ -s "$SESSION_DIR/safari_urls.txt" ]; then
        
        # Parse URLs and filter out blocked sites
        # Reverse order because 'open' adds new tabs at the end, so we need to open them backwards
        # to maintain the original left-to-right tab order
        urls=$(cat "$SESSION_DIR/safari_urls.txt" | tail -r)
        
        if [ -n "$urls" ]; then
            restored_count=0
            blocked_count=0
            
            while IFS= read -r url; do
                if [ -n "$url" ] && [ "$url" != "" ]; then
                    if is_url_blocked "$url"; then
                        blocked_count=$((blocked_count + 1))
                        echo -e "${RED}    ⚠️  Skipped blocked site: $(echo "$url" | sed 's|https://||' | sed 's|http://||' | cut -d'/' -f1)${NC}"
                    else
                        # Open URL in new tab, not new window
                        open -a "Safari" "$url" 2>/dev/null
                        restored_count=$((restored_count + 1))
                        sleep 0.1  # Small delay between tab opens
                    fi
                fi
            done <<< "$urls"
            
            # Show concise summary
            if [ $blocked_count -gt 0 ]; then
                echo -e "${YELLOW}  Safari: $restored_count tabs restored, $blocked_count blocked${NC}"
            else
                echo -e "${YELLOW}  Safari: $restored_count tabs restored${NC}"
            fi
            
            # Only return success if we actually restored tabs
            if [ $restored_count -gt 0 ]; then
                rm -f "$SESSION_DIR/safari_urls.txt"
                return 0
            fi
        fi
        
        rm -f "$SESSION_DIR/safari_urls.txt"
    fi
    return 1
}

# Restore Brave session
restore_brave_session() {
    if [ -f "$SESSION_DIR/brave_urls.txt" ] && [ -s "$SESSION_DIR/brave_urls.txt" ]; then
        
        # Parse URLs and filter out blocked sites
        # Reverse order because 'open' adds new tabs at the end, so we need to open them backwards
        # to maintain the original left-to-right tab order
        urls=$(cat "$SESSION_DIR/brave_urls.txt" | tail -r)
        
        if [ -n "$urls" ]; then
            restored_count=0
            blocked_count=0
            
            while IFS= read -r url; do
                if [ -n "$url" ] && [ "$url" != "" ]; then
                    if is_url_blocked "$url"; then
                        blocked_count=$((blocked_count + 1))
                        echo -e "${RED}    ⚠️  Skipped blocked site: $(echo "$url" | sed 's|https://||' | sed 's|http://||' | cut -d'/' -f1)${NC}"
                    else
                        # Open URL in new tab, not new window
                        open -a "Brave Browser" "$url" 2>/dev/null
                        restored_count=$((restored_count + 1))
                        sleep 0.1  # Small delay between tab opens
                    fi
                fi
            done <<< "$urls"
            
            # Show concise summary
            if [ $blocked_count -gt 0 ]; then
                echo -e "${YELLOW}  Brave: $restored_count tabs restored, $blocked_count blocked${NC}"
            else
                echo -e "${YELLOW}  Brave: $restored_count tabs restored${NC}"
            fi
            
            # Only return success if we actually restored tabs
            if [ $restored_count -gt 0 ]; then
                rm -f "$SESSION_DIR/brave_urls.txt"
                return 0
            fi
        fi
        
        rm -f "$SESSION_DIR/brave_urls.txt"
    fi
    return 1
}


# Get list of applications currently visible in the dock (excluding dev tools)
get_dock_active_apps() {
    osascript << 'EOF'
tell application "System Events"
    set dockApps to {}
    set excludedApps to {"Cursor", "Warp", "Terminal"}
    repeat with proc in (processes whose visible is true)
        set appName to (name of proc as string)
        if appName is not "" and appName is not in excludedApps then
            set end of dockApps to appName
        end if
    end repeat
    set AppleScript's text item delimiters to linefeed
    set appList to dockApps as string
    set AppleScript's text item delimiters to ""
    return appList
end tell
EOF
}

# Check if an app is currently visible in the dock
is_app_in_dock() {
    local app_name="$1"
    local dock_apps=$(get_dock_active_apps)
    echo "$dock_apps" | grep -q "^$app_name$"
}

# Check if a browser has saved tabs that we want to restore later
browser_has_saved_tabs() {
    local app_name="$1"
    case "$app_name" in
        "Google Chrome")
            [ -f "$SESSION_DIR/chrome_urls.txt" ] && [ -s "$SESSION_DIR/chrome_urls.txt" ]
            ;;
        "Safari")
            [ -f "$SESSION_DIR/safari_urls.txt" ] && [ -s "$SESSION_DIR/safari_urls.txt" ]
            ;;
        "Brave Browser")
            [ -f "$SESSION_DIR/brave_urls.txt" ] && [ -s "$SESSION_DIR/brave_urls.txt" ]
            ;;
        *)
            false  # Not a browser we track
            ;;
    esac
}

# Check if browser has productive (non-blocked) tabs worth preserving
browser_has_productive_tabs() {
    local app_name="$1"
    local session_file=""
    
    case "$app_name" in
        "Google Chrome")
            session_file="$SESSION_DIR/chrome_urls.txt"
            ;;
        "Safari")
            session_file="$SESSION_DIR/safari_urls.txt"
            ;;
        "Brave Browser")
            session_file="$SESSION_DIR/brave_urls.txt"
            ;;
        *)
            return 1  # Not a browser we track, assume productive
            ;;
    esac
    
    # If no session file, assume browser might have productive tabs
    if [ ! -f "$session_file" ] || [ ! -s "$session_file" ]; then
        return 0  # Err on side of caution
    fi
    
    # Check if ANY URL in the session is NOT blocked (i.e., productive)
    while IFS= read -r url; do
        if [ -n "$url" ]; then
            if ! is_url_blocked "$url"; then
                return 0  # Found at least one productive tab
            fi
        fi
    done < "$session_file"
    
    return 1  # All tabs are blocked/distracting
}

# Quit an application gracefully using AppleScript
quit_app() {
    local app_name="$1"
    osascript << EOF 2>/dev/null
tell application "$app_name"
    if it is running then
        quit
    end if
end tell
EOF
}

# Force close browsers without session restoration
force_close_browsers() {
    if [ "$DOCK_ONLY_MODE" = "true" ]; then
        echo -e "${BLUE}Quitting dock-active apps...${NC}"
        
        # Get all dock-active apps and quit them (excluding dev tools and browsers with saved tabs)
        local dock_apps=$(get_dock_active_apps)
        local quit_count=0
        local preserved_count=0
        
        while IFS= read -r app_name; do
            if [ -n "$app_name" ]; then
                # Check if this is a browser with saved tabs
                if browser_has_saved_tabs "$app_name"; then
                    echo -e "${BLUE}  Preserving: $app_name (has saved tabs for restoration)${NC}"
                    preserved_count=$((preserved_count + 1))
                else
                    echo -e "${YELLOW}  Quitting: $app_name${NC}"
                    quit_app "$app_name"
                    quit_count=$((quit_count + 1))
                fi
            fi
        done <<< "$dock_apps"
        
        # Show summary
        if [ $quit_count -gt 0 ] || [ $preserved_count -gt 0 ]; then
            if [ $quit_count -gt 0 ] && [ $preserved_count -gt 0 ]; then
                echo -e "${GREEN}✓ Quit $quit_count apps, preserved $preserved_count browsers with saved tabs${NC}"
            elif [ $quit_count -gt 0 ]; then
                echo -e "${GREEN}✓ Quit $quit_count dock-active apps${NC}"
            else
                echo -e "${BLUE}✓ Preserved $preserved_count browsers with saved tabs (no other apps to quit)${NC}"
            fi
        else
            echo -e "${YELLOW}No dock-active apps to quit${NC}"
        fi
    else
        # Original behavior - force close all browsers
        echo -e "${BLUE}Force closing browsers...${NC}"
        # Force quit browsers with SIGKILL to prevent session saving
        pkill -9 -f "Google Chrome" 2>/dev/null
        pkill -9 -f "Brave Browser" 2>/dev/null
        pkill -9 -f "Safari" 2>/dev/null
        pkill -9 -f "Comet" 2>/dev/null
        
        # Also kill any remaining processes
        pkill -9 chrome 2>/dev/null
        pkill -9 brave 2>/dev/null  
        pkill -9 safari 2>/dev/null
        pkill -9 comet 2>/dev/null
    fi
    
    sleep 3  # Give apps time to fully quit/close
}

# Save all browser tabs and close browsers - concise output with summary counts
save_and_close_browsers() {
    echo -e "${BLUE}Saving browser tabs...${NC}"
    init_session_dir
    
    # Save tabs first - track how many browsers had tabs saved
    browsers_saved=0
    save_chrome_session && browsers_saved=$((browsers_saved + 1))
    save_safari_session && browsers_saved=$((browsers_saved + 1))
    save_brave_session && browsers_saved=$((browsers_saved + 1))
    
    if [ $browsers_saved -gt 0 ]; then
        echo -e "${GREEN}✓ Saved tabs from $browsers_saved browser(s)${NC}"
    fi
    
    # Force close browsers to prevent auto-restoration
    force_close_browsers
}

# Restore all browser tabs - shows per-browser tab counts with blocked sites filtered
restore_browser_sessions() {
    echo -e "${BLUE}Restoring browser tabs...${NC}"
    # Wait a moment for hosts file changes to take effect
    sleep 1
    
    # Restore tabs - track how many browsers had tabs restored
    browsers_restored=0
    restore_chrome_session && browsers_restored=$((browsers_restored + 1))
    restore_safari_session && browsers_restored=$((browsers_restored + 1))
    restore_brave_session && browsers_restored=$((browsers_restored + 1))
    
    if [ $browsers_restored -gt 0 ]; then
        echo -e "${GREEN}✓ Restored tabs in $browsers_restored browser(s)${NC}"
    fi
}

# Mid-session cleanup: use the exact same process as initial focus mode
mid_session_cleanup() {
    if [ "$DOCK_ONLY_MODE" = "true" ]; then
        echo -e "${BLUE}🧹 Mid-session cleanup: refreshing focus...${NC}"
        
        # Use the EXACT same process as initial focus mode:
        # 1. Save browser tabs and close browsers (filters out distracting tabs automatically)
        save_and_close_browsers
        
        # 2. Quit other dock-active apps (non-browsers)
        local dock_apps=$(get_dock_active_apps)
        local quit_count=0
        
        while IFS= read -r app_name; do
            if [ -n "$app_name" ]; then
                # Skip browsers since save_and_close_browsers already handled them
                case "$app_name" in
                    "Google Chrome"|"Safari"|"Brave Browser"|"Comet")
                        # Already handled by save_and_close_browsers
                        ;;
                    *)
                        echo -e "${YELLOW}  Quitting: $app_name${NC}"
                        quit_app "$app_name"
                        quit_count=$((quit_count + 1))
                        ;;
                esac
            fi
        done <<< "$dock_apps"
        
        if [ $quit_count -gt 0 ]; then
            echo -e "${GREEN}✓ Quit $quit_count additional apps${NC}"
        fi
        
        # 3. Restore browser tabs (only the productive ones, just like initial focus)
        restore_browser_sessions
        
        return 0
    fi
}

# Add focus block entries to hosts file
focus_on() {
    # Handle dock-only mode when focus is already active (mid-session cleanup)
    if is_focused && [ "$DOCK_ONLY_MODE" = "true" ]; then
        mid_session_cleanup
        return 0
    fi
    
    if is_focused; then
        echo -e "${YELLOW}Focus mode is already active!${NC}"
        echo -e "${BLUE}💡 Tip: Use 'focus -d' for mid-session cleanup to quit distracting apps${NC}"
        return 0
    fi
    
    echo -e "${BLUE}Activating focus mode...${NC}"
    
    # Save browser tabs and close browsers to ensure they pick up the new hosts entries
    save_and_close_browsers
    
    backup_hosts
    
    # Create temporary file with blocked sites
    TEMP_FILE=$(mktemp)
    {
        echo ""
        echo "$FOCUS_MARKER"
        echo "# Blocked by Focus Blocker - $(date)"
        get_blocked_sites | while read -r site; do
            if [ -n "$site" ]; then
                echo "127.0.0.1 $site"
                echo "127.0.0.1 www.$site"
                echo "::1 $site"
                echo "::1 www.$site"
            fi
        done
        echo "$FOCUS_MARKER_END"
    } > "$TEMP_FILE"
    
    # Append to hosts file
    sudo sh -c "cat '$TEMP_FILE' >> '$HOSTS_FILE'"
    rm "$TEMP_FILE"
    
    # Flush DNS cache
    sudo dscacheutil -flushcache
    sudo killall -HUP mDNSResponder 2>/dev/null
    
    blocked_count=$(get_blocked_sites | wc -l | tr -d ' ')
    echo -e "${GREEN}✓ Focus mode activated! Blocked $blocked_count websites.${NC}"
    
    # Enable Do Not Disturb
    enable_dnd
    
    # Restore browser tabs
    restore_browser_sessions
}

# Check if DND shortcuts exist and provide setup instructions if needed
check_dnd_shortcuts() {
    local missing_shortcuts=0
    
    # Check if DND ON shortcut exists
    if ! shortcuts list 2>/dev/null | grep -q "^DND ON$"; then
        missing_shortcuts=1
        echo -e "${YELLOW}⚠️  'DND ON' shortcut not found${NC}"
    fi
    
    # Check if DND OFF shortcut exists
    if ! shortcuts list 2>/dev/null | grep -q "^DND OFF$"; then
        missing_shortcuts=1
        echo -e "${YELLOW}⚠️  'DND OFF' shortcut not found${NC}"
    fi
    
    if [ $missing_shortcuts -eq 1 ]; then
        echo -e "${BLUE}To enable Do Not Disturb support, please create these shortcuts:${NC}"
        echo -e ""
        echo -e "${GREEN}1. Create 'DND ON' shortcut:${NC}"
        echo -e "   • Open Shortcuts app"
        echo -e "   • Click '+' to create new shortcut"
        echo -e "   • Search for and add 'Set Focus' action"
        echo -e "   • Set it to 'Do Not Disturb' (On until turned off)"
        echo -e "   • Name the shortcut exactly: ${YELLOW}DND ON${NC}"
        echo -e ""
        echo -e "${GREEN}2. Create 'DND OFF' shortcut:${NC}"
        echo -e "   • Create another new shortcut"
        echo -e "   • Search for and add 'Turn Off Focus' action"
        echo -e "   • Name the shortcut exactly: ${YELLOW}DND OFF${NC}"
        echo -e ""
        echo -e "${BLUE}Once created, run focus again to use Do Not Disturb${NC}"
        return 1
    fi
    return 0
}

# Enable Do Not Disturb mode
enable_dnd() {
    # First try using the custom shortcuts if they exist
    if shortcuts list 2>/dev/null | grep -q "^DND ON$"; then
        echo -e "${BLUE}Enabling Do Not Disturb...${NC}"
        shortcuts run "DND ON" 2>/dev/null
        echo -e "${GREEN}✓ Do Not Disturb enabled${NC}"
    else
        # Fallback: Try direct methods to enable DND
        echo -e "${BLUE}Enabling Do Not Disturb...${NC}"
        
        # Method 1: Use Focus mode via osascript (works on newer macOS)
        if osascript -e 'tell application "System Events" to do shell script "shortcuts run \"Set Focus\" <<< \"Do Not Disturb\""' 2>/dev/null; then
            echo -e "${GREEN}✓ Do Not Disturb enabled${NC}"
        # Method 2: Use the menu bar Control Center
        elif osascript << 'EOF' 2>/dev/null
tell application "System Events"
    tell application process "ControlCenter"
        set focusButton to menu bar item "Focus" of menu bar 1
        if exists focusButton then
            click focusButton
            delay 0.5
            click menu item "Do Not Disturb" of menu 1 of focusButton
        end if
    end tell
end tell
EOF
        then
            echo -e "${GREEN}✓ Do Not Disturb enabled${NC}"
        else
            # If none work, provide instructions for first-time setup
            if [ ! -f "$HOME/.focus_blocker_dnd_warned" ]; then
                echo -e ""
                check_dnd_shortcuts
                touch "$HOME/.focus_blocker_dnd_warned"
                echo -e "${YELLOW}Continuing without Do Not Disturb...${NC}"
            else
                echo -e "${YELLOW}⚠️  Could not enable Do Not Disturb automatically${NC}"
            fi
        fi
    fi
}

# Disable Do Not Disturb mode
disable_dnd() {
    # First try using the custom shortcuts if they exist
    if shortcuts list 2>/dev/null | grep -q "^DND OFF$"; then
        echo -e "${BLUE}Disabling Do Not Disturb...${NC}"
        shortcuts run "DND OFF" 2>/dev/null
        echo -e "${GREEN}✓ Do Not Disturb disabled${NC}"
    else
        # Fallback: Try direct methods to disable DND
        echo -e "${BLUE}Disabling Do Not Disturb...${NC}"
        
        # Method 1: Turn off Focus via menu bar
        if osascript << 'EOF' 2>/dev/null
tell application "System Events"
    tell application process "ControlCenter"
        set focusButton to menu bar item "Focus" of menu bar 1
        if exists focusButton then
            click focusButton
            delay 0.5
            -- Look for and click "Do Not Disturb" if it's checked (on)
            try
                click menu item "Do Not Disturb" of menu 1 of focusButton
            end try
        end if
    end tell
end tell
EOF
        then
            echo -e "${GREEN}✓ Do Not Disturb disabled${NC}"
        else
            echo -e "${YELLOW}⚠️  Could not disable Do Not Disturb automatically${NC}"
        fi
    fi
}

# Remove focus block entries from hosts file
focus_off() {
    if ! is_focused; then
        echo -e "${YELLOW}Focus mode is not currently active.${NC}"
        return 0
    fi
    
    echo -e "${BLUE}Deactivating focus mode...${NC}"
    
    # Remove focus blocker section from hosts file
    sudo sed -i.bak "/$FOCUS_MARKER/,/$FOCUS_MARKER_END/d" "$HOSTS_FILE"
    
    # Flush DNS cache
    sudo dscacheutil -flushcache
    sudo killall -HUP mDNSResponder 2>/dev/null
    
    # Disable Do Not Disturb
    disable_dnd
    
    echo -e "${GREEN}✓ Focus mode deactivated! All sites unblocked.${NC}"
}

# List currently blocked sites
list_sites() {
    echo -e "${BLUE}Currently configured blocked sites:${NC}"
    if [ -f "$CONFIG_FILE" ]; then
        get_blocked_sites | while read -r site; do
            if [ -n "$site" ]; then
                if is_focused; then
                    echo -e "  ${RED}🚫 $site (blocked)${NC}"
                else
                    echo -e "  ${YELLOW}⚠️  $site (not blocked)${NC}"
                fi
            fi
        done
        
        if is_focused; then
            echo -e "\n${GREEN}Focus mode is currently: ACTIVE${NC}"
        else
            echo -e "\n${YELLOW}Focus mode is currently: INACTIVE${NC}"
        fi
    else
        echo -e "${RED}No config file found. Run 'focus' to create one.${NC}"
    fi
}

# Add a site to block list
add_site() {
    local site="$1"
    if [ -z "$site" ]; then
        echo -e "${RED}Please specify a site to add${NC}"
        echo "Usage: focus add <site>"
        return 1
    fi
    
    # Remove protocol and www prefix if present
    site=$(echo "$site" | sed 's|https\?://||' | sed 's|^www\.||')
    
    init_config
    
    if grep -q "^$site$" "$CONFIG_FILE" 2>/dev/null; then
        echo -e "${YELLOW}Site '$site' is already in the block list${NC}"
    else
        echo "$site" >> "$CONFIG_FILE"
        echo -e "${GREEN}✓ Added '$site' to block list${NC}"
        
        if is_focused; then
            echo -e "${BLUE}Reactivating focus mode with new site...${NC}"
            focus_off
            focus_on
        fi
    fi
}

# Remove a site from block list
remove_site() {
    local site="$1"
    if [ -z "$site" ]; then
        echo -e "${RED}Please specify a site to remove${NC}"
        echo "Usage: focus remove <site>"
        return 1
    fi
    
    # Remove protocol and www prefix if present
    site=$(echo "$site" | sed 's|https\?://||' | sed 's|^www\.||')
    
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${RED}No config file found${NC}"
        return 1
    fi
    
    if grep -q "^$site$" "$CONFIG_FILE"; then
        grep -v "^$site$" "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
        echo -e "${GREEN}✓ Removed '$site' from block list${NC}"
        
        if is_focused; then
            echo -e "${BLUE}Reactivating focus mode without removed site...${NC}"
            focus_off
            focus_on
        fi
    else
        echo -e "${YELLOW}Site '$site' was not found in the block list${NC}"
    fi
}

# Show help
show_help() {
    echo -e "${BLUE}Focus Blocker - Website blocking utility${NC}"
    echo ""
    echo "Commands:"
    echo "  focus [--dock-only|-d]   - Activate focus mode (block sites). With --dock-only, quit dock-active apps. Also works mid-session for cleanup!"
    echo "  focus -s [name]          - Activate focus mode + launch Spotify playlist"
    echo "  unfocus                  - Deactivate focus mode (unblock sites)"
    echo "  focus list               - Show blocked sites and current status"
    echo "  focus playlists          - Show available Spotify playlists"
    echo "  focus playlist add <name> <url> - Add a Spotify playlist"
    echo "  focus playlist remove <name>    - Remove a Spotify playlist"
    echo "  focus add <site>         - Add a site to block list"
    echo "  focus remove <site>      - Remove a site from block list"
    echo ""
    echo "  focus help               - Show this help"
    echo ""
    echo "Examples:"
    echo "  focus add x.com"
    echo "  focus add reddit.com"
    echo "  focus remove youtube.com"
    echo "  focus -d                 # Block sites and quit dock-active apps (or mid-session cleanup if already focused)"
    echo "  focus --dock-only        # Same as above"
    echo ""
    echo "  # Mid-session cleanup examples (SAFE - never quits browsers mid-session):"
    echo "  focus -d                 # While focused: quit distracting non-browser apps (preserves all browsers)"
    echo "  focus -s                 # Block sites and start default playlist"
    echo "  focus -s lofi            # Block sites and start 'lofi' playlist"
    echo "  focus playlist add lofi https://open.spotify.com/playlist/37i9dQZF1DWWQRwui0ExPn"
    echo "  focus playlist remove lofi"
    echo ""
    echo -e "${YELLOW}Config files:${NC}"
    echo -e "  Blocked sites: $CONFIG_FILE"
    echo -e "  Spotify config: $SPOTIFY_CONFIG_FILE"
}

# Parse flags (support --dock-only/-d before command)
while [ $# -gt 0 ]; do
    case "$1" in
        --dock-only|-d)
            DOCK_ONLY_MODE=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Main logic
case "$1" in
    "")
        init_config
        focus_on
        ;;
    "-s")
        init_config
        focus_on
        # Support optional dock-only flag in position 3 as well (focus -s <name> --dock-only)
        # Note: DOCK_ONLY_MODE is already set if flag was before -s
        if [ "$3" = "--dock-only" ] || [ "$3" = "-d" ]; then
            DOCK_ONLY_MODE=true
        fi
        launch_spotify_focus "$2"
        ;;
    "list")
        init_config
        list_sites
        ;;
    "playlists")
        init_spotify_config
        list_playlists
        ;;
    "playlist")
        case "$2" in
            "add")
                add_playlist "$3" "$4"
                ;;
            "remove")
                remove_playlist "$3"
                ;;
            *)
                echo -e "${RED}Unknown playlist command: $2${NC}"
                echo "Usage: focus playlist [add|remove] ..."
                echo "  focus playlist add <name> <url>"
                echo "  focus playlist remove <name>"
                exit 1
                ;;
        esac
        ;;
    "add")
        add_site "$2"
        ;;
    "remove")
        remove_site "$2"
        ;;
    "help")
        show_help
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        show_help
        exit 1
        ;;
esac
